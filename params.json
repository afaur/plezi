{"name":"AnoreXic","tagline":"A small, pure Ruby, web app DSL/framework... so small - it's anorexic!","body":"# Anorexic\r\n[![Gem Version](https://badge.fury.io/rb/anorexic.svg)](http://badge.fury.io/rb/anorexic)\r\n[![Inline docs](http://inch-ci.org/github/boazsegev/anorexic.svg?branch=master)](http://inch-ci.org/github/boazsegev/anorexic)\r\n\r\nA thin, lightweight, barebones, mutli-threaded Ruby alternative to Rails (ROR) and Sinatra frameworks... so thin, it's anorexic!\r\n\r\nThe philosophy is simple - pristine, simple and dedicated gems for each functionality allow for a custom made framework that is exactly the right size during runtime.\r\n\r\nAnorexic is a barebones DLS that can run with or without Rack and offers single-port as well as multi-port service for basic and advanced web services alike.\r\n\r\n...and since it's all pure Ruby, it's as easy as it gets.\r\n\r\n## Installation\r\n\r\ninstall it using:\r\n\r\n    $ gem install anorexic\r\n\r\n## Framework Usage\r\n\r\nto create a new barebones app using the Anorexic framework, run from terminal:\r\n\r\n    $ anorexic new appname\r\n\r\nThat's it, now you have a ready to use basic web server (with some demo code), just run it:\r\n\r\n    $ cd appname\r\n    $ ./appname.rb # ( or: anorexic s )\r\n\r\nthis is a smart framework app that comes very skinny and will happily eat any gem you feed it. it responds extra well to Thin and Haml, which you can enable in it's Gemfile.\r\n\r\nnow go, in your browser, to: http://localhost:3000/\r\n\r\nthe default first port for the app is 3000. you can set the first port to listen to by using the `-p ` option (make sure you have permissions for the requested port):\r\n\r\n    $ ./appname.rb -p 80\r\n\r\n## Barebones Web Service\r\n\r\nAnorexic contains a simple single-use DSL (all the DLS methods are removed once the server starts running - less clutter while running).\r\n\r\nyou can run anorexic from your favorite Ruby terminal :) - Anorexic starts the moment you exit the terminal.\r\n\r\nAnorexic creates a whole web service with three commands that speek for themselves:\r\n- listen\r\n- route\r\n- shared_route\r\n\r\nthis example is basic, useless, but required for every doc out there...\r\n\r\n\"Hello World!\" in 3 lines - try it in irb (exit irb to start server):\r\n\r\n\t\trequire 'anorexic'\r\n\t\tlisten\r\n\t\troute(/.?/) { |req, res| res.body << \"Hello World!\" }\r\n\r\nAfter you exited irb, the Anorexic server started up. go to http://localhost:3000/ and see it run :)\r\n\r\nif more then one `listen` call was made, ports will be sequential (3000, 3001, 3002...) unless explicitly set(`listen 443`).\r\n\r\n*btw*: did you notice the catch-all regular-expression? you can write it like this too:\r\n\r\n\t\trequire 'anorexic'\r\n\t\tlisten\r\n\t\troute('*') { |req, res| res.body << \"Hello World!\" }\r\n\r\nHere's a simple web server, complete with SSL (supported on Thin and webrick servers), in three (+1) lines of code, serving static pages from the `public` folder::\r\n\r\n\t\trequire 'anorexic'\r\n\r\n\t\t# set up a non-secure service on port 3000\r\n\t\tlisten 3000, file_root: File.expand_path(File.join(Dir.pwd , 'public'))\r\n\r\n\t\t# set up a encrypted service on port 8080, works only with some servers (i.e. thin, webrick)\r\n\t\tlisten 8080, ssl_self: true, file_root: File.expand_path(File.join(Dir.pwd , 'public')) \r\n\r\n\t\tshared_route('/people') { |req, res| res.body << \"I made this :-)\" }\r\n\r\n## Anorexic Routes\r\n\r\nRoutes have paths that tell the application which code to run for every request it recieves. when you set your browser to: `http://www.server.com/the/stuff/they/request?paramaters=params[:paramaters]` , this is the routes path: `/the/stuff/they/request`\r\n\r\nAs long as Anorexic uses the Anorexic::RackServer class (we could change that, but why would we?), the routes will work the same for all the listening ports.\r\n\r\nAnorexic allows your code to choose it's routes dynamically, in the order they are created. like so:\r\n\r\n    require 'anorexic'\r\n    listen\r\n\r\n    # this route declines to answer\r\n    route('/') { |req, res| res.body << \"I Give Up!\"; false }\r\n\r\n    # this route wins\r\n    route('/') { |req, res| res.body << \"I Win!\" }\r\n\r\n    # this route never sees the light of day\r\n    route('/') { |request, response| response.body << \"Help Me!\" }\r\n\r\nAnorexic supports magic routes, in similar formats found in other systems, such as: `route \"/:required/(:optional)/(:optional_with_format){[\\\\d]*}\", Controler` -  **please see the `route` documentation for more information on routes**.\r\n\r\nAnorexic assummes all simple string routes to be RESTful routes ( `\"/user\" == \"/user/(:id)\"` ).\r\n\r\n    require 'anorexic'\r\n    listen\r\n\r\n    # this route demos a route for listing/showing posts,\r\n    # with or without revision numbers or page-control....\r\n    route \"/post/(:id)/(:revision){[\\d]*}/(:page_number)\", Anorexic::StubController\r\n\r\nAnorexic accepts Regexp routes as well as string and magic routes and defines a short cut for a catch-all route:\r\n\r\n    require 'anorexic'\r\n    listen\r\n\r\n    # this route accepts paths that start with a number (i.e.: /nonumber)\r\n    route(/^\\/[\\d]+[\\D]+/) { |req, res| res.body << \"Give me more numbers :)\" }\r\n\r\n    # this route accepts paths that are just numbers (i.e.: /87652)\r\n    route(/^\\/[\\d]+$/) { |req, res| res.body << \"I Love Numbers!\" }\r\n\r\n    # this route accepts paths that don't have any number (i.e.: /nonumber)\r\n    route(/^\\/[\\D]+$/) { |req, res| res.body << \"Where're my numbers :(\" }\r\n\r\n    # this route catches everything else.\r\n    route('*') { |request, response| response.body << \"Gotcha!\" }\r\n\r\n## Anorexic Virtual Hosts\r\n\r\nThe Anorexic `listen` command can be used to create virtual hosts for the same service, by supplying a port that is already assigned:\r\n\r\n    require 'anorexic'\r\n\r\n    # sets a virtuls host on localhost 1 (saving the server object to use it's port)\r\n    server = listen host: 'localhost'\r\n\r\n    route('/welcome') { |req, res| res.body << \"Welcome to Localhost.\" }\r\n\r\n    # sets a virtuls host on admin.localhost1\r\n    # (using the same port creates a virtual host instead of a new service)\r\n    admin_host = listen server.port, host: '127.0.0.1'\r\n\r\n    route('/welcome') { |req, res| res.body << \"Administrate Localhost.\" }\r\n\r\n    # sets a global router for the same service\r\n    # (for any host NOT localhost1 or admin.localhost1 )\r\n    listen server.port\r\n    route('/welcome') { |req, res| res.body << \"Welcome to the global namespace\" }\r\n\r\n    # virtual hosts support shared routes, just like real services\r\n    shared_route('/people') { |req, res| res.body << \"we made this!\" }\r\n\r\n    # it's possible to directly add routes to an \"older\" host, if you saved it.\r\n    # (this works also as live route adding)\r\n    admin_host.add_route('/secret') { |req, res| res.body << \"Shhhh!\" }\r\n\r\n    # shared routes can be catch-all (careful).\r\n    shared_route('*') { |req, res| res.body << \"Gotcha!\" }\r\n\r\n## Anorexic Controller classes\r\n\r\nOne of the best things about the Anorexic is it's ability to take in any class as a controller class and route to the classes methods with special support for RESTful methods (index, show, save, update, delete, before and after):\r\n\r\n\t\trequire 'pry'\r\n\t\trequire 'anorexic'\r\n\t\trequire 'thin' # will change the default server to thin automatically.\r\n\r\n\t\tclass Controller\r\n\t\t\tdef index\r\n\t\t\t\t\"Hello World!\"\r\n\t\t\tend\r\n\t\t\tdef show\r\n\t\t\t\t\"You're looking for: #{params[:id]}\"\r\n\t\t\tend\r\n\t\t\tdef debug\r\n\t\t\t\tbinding.pry\r\n\t\t\t\ttrue\r\n\t\t\tend\r\n\t\t\tdef delete\r\n\t\t\t\t\"did you try /#{params[\"id\"]}/?_method=delete\"\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tlisten\r\n\t\troute \"/users\" , Controller\r\n\t\troute \"/\" , Controller\r\n\r\nControllers can even be nested (order matters) or have advanced uses that are definitly worth exploring.\r\n\r\nHere's some food for thought - code similar to something actually used in the framework app:\r\n\r\n\t\trequire 'pry'\r\n\t\trequire 'anorexic'\r\n\t\trequire 'thin'\r\n\r\n\t\tclass ReWriteController\r\n\t\t\t# using the before filter and regular expressions to make some changes.\r\n\t\t\tdef before\r\n\t\t\t\tresult = request.path.match /^\\/(en|fr)($|\\/.*)/\r\n\t\t\t\tif result\r\n\t\t\t\t\tparams[\"locale\"] = result[1].to_sym\r\n\t\t\t\t\trequest.path_info = result[2]\r\n\t\t\t\tend\r\n\t\t\t\treturn false\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tclass Controller\r\n\t\t\tdef index\r\n\t\t\t\treturn \"Bonjour le monde!\" if params[:locale] == :fr\r\n\t\t\t\t\"Hello World!\"\r\n\t\t\tend\r\n\t\t\tdef show\r\n\t\t\t\treturn \"Vous êtes à la recherche d' : #{params[:id]}\" if params[:locale] == :fr\r\n\t\t\t\t\"You're looking for: #{params[:id]}\"\r\n\t\t\tend\r\n\t\t\tdef debug\r\n\t\t\t\tbinding.pry\r\n\t\t\t\ttrue\r\n\t\t\tend\r\n\t\t\tdef delete\r\n\t\t\t\t\"Mon Dieu! Mon français est mauvais!\" if params[:locale] == :fr\r\n\t\t\t\t\"did you try /#{params[\"id\"]}/?_method=delete\"\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tlisten\r\n\r\n\t\troute \"*\" , ReWriteController\r\n\r\n\t\troute /^\\/[\\d\\+\\-\\*\\/\\(\\)\\.]+$/ do |request, response|\r\n\t\t\tmessage = (request.params[:locale] == :fr) ? \"La solution est\" : \"My Answer is\"\r\n\t\t\tresponse.body << \"#{message}: #{eval(request.path[1..-1])}\"\r\n\t\tend\r\n\r\n\t\troute \"/users\" , Controller\r\n\r\n\t\troute \"/\" , Controller\r\n\r\ntry:\r\n\r\n* http://localhost:3000/\r\n* http://localhost:3000/users\r\n* http://localhost:3000/users/hello\r\n* http://localhost:3000/(5+5*20-15)/9\r\n\r\n## Anorexic is hungry for pristine yummy gems\r\n\r\nThis is the \"Pristine chunks\" phylosophy.\r\n\r\nOur needs are totally different for each project. An XML web service for an iPhone native app is a very different animal then a book-store web app (please, not another book store app...).\r\n\r\nTogether we can write add-ons and features and beautifuls gems that we will use when (and if) we need them - so our apps are always happy and never overweight!\r\n\r\n## What about Ruby on Rails or Sinatra?\r\n\r\nI love the Ruby community and I know that we are realy good at writing gems and plug-ins that save a lot of time and code. But we don't need all the plug-ins all the time.\r\n\r\nRuby on Rails became too bloated and big for some projects... It's full of great features that some of them are sometimes used... but at the end of the day, it's HEAVY.\r\n\r\nLooking into Sinatra benchmarks on the web showed that Rails and Sinatra frameworks perform on a similar level. The added 'lightness' just wasn't light enough.\r\n\r\nSome of us started reverting to pure Rack, and a lot of code kept being written over and over again... Actually, Anorexic is just a smart wrapper to Rack, to make routing and MVC (Model-View-Controller) programming easier.\r\n\r\nSo sure, you can use Rails or Sinatra, they're great, but we Love to feed Anorexic our code, it just eats it up so nicely.\r\n\r\n# Feed the Anorexic framework\r\n\r\nThe whole of the Anorexic framework philosophy is about community, sharing and feeding the anorexic framework with small and pristine gems.\r\n\r\nPlease, feel free to contribute, push any changes on the github project and create your own gems to feed the Anorexic open framework.\r\n\r\n## Contributing\r\n\r\n\r\n1. Fork it ( https://github.com/boazsegev/anorexic/fork )\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create a new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}