{"name":"AnoreXic","tagline":"A small, pure Ruby, web framework-server... so small - it's anorexic!","body":"# Anorexic - a r/evolution\r\n[![Gem Version](https://badge.fury.io/rb/anorexic.svg)](http://badge.fury.io/rb/anorexic)\r\n[![Inline docs](http://inch-ci.org/github/boazsegev/anorexic.svg?branch=master)](http://inch-ci.org/github/boazsegev/anorexic)\r\n\r\n> People who are serious about their frameworks, should make their own servers...\r\n_(if to para-phrase \"People who are serious about their software, should make their own hardware.\")_\r\n\r\n## About the Anorexic framework \\ server\r\n\r\nA thin, lightweight, barebones, mutli-threaded Ruby alternative to Rack/Rails/Sintra.\r\n\r\nAnorexic contains an object-oriented server, divided into parts that can be changed/updated and removed easily and dynamically. The Anorexic framework runs HTTP and WebSockets, but could as easily be extended to run SMTP, SPDY or any other Protocol (including custom made protocols).\r\n\r\nThis allows - much like Node.js - native WebSocket support (and, if you would like to write your own Protocol or Handler, native SMPT or any other custom protocol you might wish to implement).\r\n\r\nYou can follow our [tutorial to write your first Anorexic Chatroom](http://boazsegev.github.io/anorexic/websockets.html) - but first I advise to read this readme and explore the WebSockets example given here.\r\n\r\n## Installation\r\n\r\nAdd this line to your application's Gemfile:\r\n\r\n```ruby\r\ngem 'anorexic'\r\n```\r\nOr install it yourself as:\r\n\r\n    $ gem install anorexic\r\n\r\n## Creating an Anorexic Application\r\n\r\nto create a new barebones app using the Anorexic framework, run from terminal:\r\n\r\n    $ anorexic new appname\r\n\r\nThat's it, now you have a ready to use basic web server (with some demo code), just run it:\r\n\r\n    $ cd appname\r\n    $ ./appname.rb # ( or: anorexic s )\r\n\r\nnow go, in your browser, to: [http://localhost:3000/](http://localhost:3000/)\r\n\r\nthe default first port for the app is 3000. you can set the first port to listen to by using the `-p ` option (make sure you have permissions for the requested port):\r\n\r\n    $ ./appname.rb -p 80\r\n\r\nyou now have a smart framework app that will happily eat any gem you feed it. it responds extra well to Haml, Sass and Coffee-Script, which you can enable in it's Gemfile.\r\n\r\n## Barebones Web Service\r\n\r\nthis example is basic, useless, but required for every doc out there...\r\n\r\n\"Hello World!\" in 3 lines - try it in irb (exit irb to start server):\r\n\r\n\t\trequire 'anorexic'\r\n\t\tlisten\r\n\t\troute(/.?/) { |req, res| res << \"Hello World!\" }\r\n\r\nAfter you exited irb, the Anorexic server started up. go to http://localhost:3000/ and see it run :)\r\n\r\n## Anorexic Routes\r\n\r\nAnorexic supports magic routes, in similar formats found in other systems, such as: `route \"/:required/(:optional)/(:optional_with_format){[\\\\d]*}\", Controler`.\r\n\r\nAnorexic assummes all simple string routes to be RESTful routes ( `\"/user\" == \"/user/(:id)\"` ).\r\n\r\n    require 'anorexic'\r\n    listen\r\n\r\n    # this route demos a route for listing/showing posts,\r\n    # with or without revision numbers or page-control....\r\n    # notice the single quotes (otherwise the '\\' would need to be escaped).\r\n    route '/post/(:id)/(:revision){[\\d]+\\.[\\d]+}/(:page_number)', Anorexic::StubRESTCtrl\r\n\r\nnow visit:\r\n\r\n* [http://localhost:3000/post/12/1.3/1](http://localhost:3000/post/12/1.3/1)\r\n* [http://localhost:3000/post/12/1](http://localhost:3000/post/12/1)\r\n\r\n**please see the `route` documentation for more information on routes**.\r\n\r\n## Anorexic Virtual Hosts\r\n\r\nAnorexic can be used to create virtual hosts for the same service:\r\n\r\n    require 'anorexic'\r\n    listen\r\n    host 'localhost', alias: 'localhost2'\r\n\r\n    shared_route '/people' do |req, res|\r\n        res << \"we are people - shared by all routes.\"\r\n    end\r\n\r\n    host\r\n\r\n    route('*') do |req, res|\r\n        res << \"this is a 'catch-all' host. you got here by putting in the IP adderess.\"\r\n    end\r\n\r\n    host 'localhost'\r\n\r\n    route('*') do |req, res|\r\n        res << \"this is localhost or localhost 2\"\r\n    end\r\n\r\nNow visit:\r\n\r\n* [http://127.0.0.1:3000/]( http://127.0.0.1:3000/ )\r\n* [http://localhost:3000/]( http://localhost:3000/ )\r\n* [http://127.0.0.1:3000/people]( http://127.0.0.1:3000/people )\r\n* [http://localhost:3000/people]( http://localhost:3000/people )\r\n\r\n## Anorexic Controller classes\r\n\r\nOne of the best things about the Anorexic is it's ability to take in any class as a controller class and route to the classes methods with special support for RESTful methods (`index`, `show`, `new`, `save`, `update`, `delete`, `before` and `after`) and for WebSockets (`pre_connect`, `on_connect`, `on_message(data)`, `on_disconnect`, `broadcast`, `collect`):\r\n\r\n\t\trequire 'anorexic'\r\n\r\n\t\tclass Controller\r\n\t\t\tdef index\r\n\t\t\t\t\"Hello World!\"\r\n\t\t\tend\r\n\t\tend\r\n\r\n\t\tlisten\r\n\t\troute '*' , Controller\r\n\r\nExcept for WebSockets, returning a String will automatically add the string to the response before sending the response - which makes for cleaner code. It's also possible to send the response as it is (by returning true).\r\n\r\nControllers can even be nested (order matters) or have advanced uses that are definitly worth exploring.\r\n\r\n**please read the demo code for Anorexic::StubRESTCtrl and Anorexic::StubWSCtrl to learn more.**\r\n\r\n## Native Websocket support\r\n\r\nAnorexic Controllers have access to native websocket support through the `pre_connect`, `on_connect`, `on_message(data)`, `on_disconnect`, `broadcast` and `collect` methods.\r\n\r\nHere is some demo code for a simple Websocket broadcasting server, where messages sent to the server will be broadcasted back to all the **other** active connections (the connection sending the message will not recieve the broadcast).\r\n\r\nAs a client side, we will use the WebSockets echo demo page - we will simply put in ws://localhost:3000/ as the server, instead of the default websocket server (ws://echo.websocket.org).\r\n\r\nRemember to connect to the service from at least two browser windows - to truly experience the `broadcast`ed websocket messages.\r\n\r\n```ruby\r\n    require 'anorexic'\r\n\r\n    class BroadcastCtrl\r\n        def index\r\n            redirect_to 'http://www.websocket.org/echo.html'\r\n        end\r\n        def on_message data\r\n            broadcast :_send_message, data\r\n            response << \"sent.\"\r\n        end\r\n        def _send_message data\r\n            response << data\r\n        end\r\n        def people\r\n            'I made this :)'\r\n        end\r\n    end\r\n\r\n    listen \r\n\r\n    route '/', BroadcastCtrl\r\n```\r\n\r\nmethod names starting with an underscore ('_') will NOT be made public by the router: so while '/people' is public ( [try it](http://localhost:3000/people) ), '/_send_message' will return a 404 not found error ( [try it](http://localhost:3000/_send_message) ).\r\n\r\n## Anorexic Helpers and Logging\r\n\r\nThe Anorexic module (also `AN`) has methods to help with logging, asynchronous callbacks, dynamic routes, dynamic services and more.\r\n\r\nLogging:\r\n\r\n    require 'anorexic'\r\n\r\n    # simple logging of strings\r\n    AN.info 'log info'\r\n    AN.warn 'log warning'\r\n    AN.error 'log error'\r\n    AN.fatal \"log a fatal error (shuoldn't be needed).\"\r\n    AN.log_raw \"Write raw strings to the logger.\"\r\n\r\n    # the logger accepts exceptions as well.\r\n    begin\r\n        raise \"hell\"\r\n    rescue Exception => e\r\n        AN.error e\r\n    end\r\n\r\nAsynchronous callbacks (works only while services are active and running):\r\n\r\n    require 'anorexic'\r\n\r\n    def my_shutdown_proc time_start\r\n        puts \"Services were running for #{Time.now - time_start} seconds.\"\r\n    end\r\n\r\n    # shutdown callbacks\r\n    AN.on_shutdown(Kernel, :my_shutdown_proc, Time.now) { puts \"this will run after shutdown.\" }\r\n    AN.on_shutdown() { puts \"this will run too.\" }\r\n\r\n    AN.callback(Kernel, :puts, \"Please tell me your name?\") do\r\n        AN.callback(Kernel, :gets) {|name| puts \"hello #{name}\"}\r\n    end\r\n\r\n    puts \"Anorexic will start eating our code once we exit terminal.\"\r\n\r\n## Food for thought - advanced controller uses\r\n\r\nHere's some food for thought - code similar to something actually used at some point while developing the applicatio template used by `anorexic new myapp`:\r\n\r\n    require 'anorexic'\r\n\r\n    # this controller will re-write the request to extract data,\r\n    # and then it will fail, so that routing continues.\r\n    #\r\n    # this is here just for the demo.\r\n    #\r\n    class ReWriteController\r\n        # using the before filter and regular expressions to make some changes.\r\n        def before\r\n            # extract the fr and en locales.\r\n            result = request.path.match /^\\/(en|fr)($|\\/.*)/\r\n\r\n            if result\r\n                params[:locale] = result[1]\r\n                request.path = result[2]\r\n            end\r\n\r\n            # let the routing continue.\r\n            return false\r\n        end\r\n    end\r\n\r\n    class Controller\r\n        def index\r\n            return \"Bonjour le monde!\" if params[:locale] == 'fr'\r\n            \"Hello World!\\n #{params}\"\r\n        end\r\n        def show\r\n            return \"Vous êtes à la recherche d' : #{params[:id]}\" if params[:locale] == 'fr'\r\n            \"You're looking for: #{params[:id]}\"\r\n        end\r\n        def debug\r\n            # binding.pry\r\n            # do you use pry for debuging?\r\n            # no? oh well, let's ignore this.\r\n            false\r\n        end\r\n        def delete\r\n            return \"Mon Dieu! Mon français est mauvais!\" if params[:locale] == 'fr'\r\n            \"did you try /#{params[\"id\"]}/?_method=delete or does your server support a native DELETE method?\"\r\n        end\r\n    end\r\n\r\n    listen\r\n\r\n    # we run the ReWriteController first, to rewrite the path for all the remaining routes.\r\n    #\r\n    # this is here just for the demo...\r\n    #\r\n    # ...in this specific case, it is possible to dispense with the ReWriteController class\r\n    # and write:\r\n    #\r\n    # route '/(:locale){fr|en}/*', false\r\n    #\r\n    # the false controller acts as a simple path re-write that\r\n    # deletes everything before the '*' sign (the catch-all).\r\n    #\r\n    route '*' , ReWriteController\r\n\r\n    # this route takes a regular expression that is a simple math calculation\r\n    # (calculator)\r\n    route /^\\/[\\d\\+\\-\\*\\/\\(\\)\\.]+$/ do |request, response|\r\n        message = (request.params[:locale] == 'fr') ? \"La solution est\" : \"My Answer is\"\r\n        response << \"#{message}: #{eval(request.path[1..-1])}\"\r\n    end\r\n\r\n    route \"/users\" , Controller\r\n\r\n    route \"/\" , Controller\r\n\r\ntry:\r\n\r\n* [http://localhost:3000/](http://localhost:3000/)\r\n* [http://localhost:3000/fr](http://localhost:3000/fr)\r\n* [http://localhost:3000/users/hello](http://localhost:3000/users/hello)\r\n* [http://localhost:3000/(5+5*20-15)/9](http://localhost:3000/(5+5*20-15)/9)\r\n* [http://localhost:3000/fr/(5+5*20-15)/9](http://localhost:3000/fr/(5+5*20-15)/9)\r\n* [http://localhost:3000/users/hello?_method=delete](http://localhost:3000/users/hello?_method=delete)\r\n\r\n## Anorexic Settings\r\n\r\nAnorexic is ment to be very flexible. please take a look at the Anorexic Module for settings you might want to play with (max_threads, idle_sleep, create_logger) or any monkey patching you might enjoy.\r\n\r\nFeel free to fork or contribute. right now I am one person, but together we can make something exciting that will help us enjoy Ruby in this brave new world and (hopefully) set an example that will induce progress in the popular mainstream frameworks such as Rails and Sinatra.\r\n\r\n## Contributing\r\n\r\n1. Fork it ( https://github.com/boazsegev/anorexic-server/fork )\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create a new Pull Request\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}