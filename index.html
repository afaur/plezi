<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Plezi by boazsegev</title>
  </head>

  <body>
    <header>
      <div class="inner">
        <h1>Plezi</h1>
        <h2>A small, pure Ruby, web framework-server with native support for Websockets, RESTful routing and HTTP streaming.</h2>
        <a href="https://github.com/boazsegev/plezi" class="button"><small>View project on</small> GitHub</a>
      </div>
    </header>

    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">
          <h1>
<a id="plezi-the-ruby-websocket-and-http-framework" class="anchor" href="#plezi-the-ruby-websocket-and-http-framework" aria-hidden="true"><span class="octicon octicon-link"></span></a>Plezi, The Ruby Websocket and HTTP Framework</h1>

<p><a href="http://badge.fury.io/rb/plezi"><img src="https://badge.fury.io/rb/plezi.svg" alt="Gem Version"></a>
<a href="http://inch-ci.org/github/boazsegev/plezi"><img src="http://inch-ci.org/github/boazsegev/plezi.svg?branch=master" alt="Inline docs"></a></p>

<blockquote>
<p>People who are serious about their frameworks, should make their own servers...</p>
</blockquote>

<p><em>(if to para-phrase "People who are serious about their software, should make their own hardware.")</em></p>

<h2>
<a id="about-the-plezi-framework--server" class="anchor" href="#about-the-plezi-framework--server" aria-hidden="true"><span class="octicon octicon-link"></span></a>About the Plezi framework \ server</h2>

<p>Plezi is an easy to use Ruby Websocket Framework, with full RESTful routing support and HTTP streaming support. It's name comes from the word "fun" in Haitian, since Plezi is really fun to work with and it keeps our code clean and streamlined.</p>

<p>Plezi works as an asynchronous multi-threaded Ruby alternative to a Rack/Rails/Sintra/Faye/EM-Websockets combo. It's also great as an alternative to socket.io, allowing for both websockets and long pulling.</p>

<p>Plezi contains an object-oriented server, divided into parts that can be changed/updated and removed easily and dynamically. This allows - much like Node.js - native WebSocket support (and, if you would like to write your own Protocol or Handler, native SMPT or any other custom protocol you might wish to implement).</p>

<p>You can follow our <a href="http://boazsegev.github.io/plezi/websockets.html">tutorial to write your first Plezi Chatroom</a> - but it's better to start with this readme and explore the WebSockets example given here.</p>

<h2>
<a id="installation" class="anchor" href="#installation" aria-hidden="true"><span class="octicon octicon-link"></span></a>Installation</h2>

<p>Add this line to your application's Gemfile:</p>

<div class="highlight highlight-ruby"><pre><span class="pl-k">gem</span> <span class="pl-s1"><span class="pl-pds">'</span>plezi<span class="pl-pds">'</span></span></pre></div>

<p>Or install it yourself as:</p>

<pre><code>$ gem install plezi
</code></pre>

<h2>
<a id="creating-an-plezi-application" class="anchor" href="#creating-an-plezi-application" aria-hidden="true"><span class="octicon octicon-link"></span></a>Creating an Plezi Application</h2>

<p>to create a new barebones app using the Plezi framework, run from terminal:</p>

<pre><code>$ plezi new appname
</code></pre>

<p>That's it, now you have a ready to use basic web server (with some demo code), just run it:</p>

<pre><code>$ cd appname
$ ./appname.rb # ( or: plezi s )
</code></pre>

<p>now go, in your browser, to: <a href="http://localhost:3000/">http://localhost:3000/</a></p>

<p>the default first port for the app is 3000. you can set the first port to listen to by using the <code>-p</code> option (make sure you have permissions for the requested port):</p>

<pre><code>$ ./appname.rb -p 80
</code></pre>

<p>you now have a smart framework app that will happily eat any gem you feed it. it responds extra well to Haml, Sass and Coffee-Script, which you can enable in it's Gemfile.</p>

<h2>
<a id="barebones-web-service" class="anchor" href="#barebones-web-service" aria-hidden="true"><span class="octicon octicon-link"></span></a>Barebones Web Service</h2>

<p>this example is basic, useless, but required for every doc out there...</p>

<p>"Hello World!" in 3 lines - try it in irb (exit irb to start server):</p>

<pre><code>    require 'plezi'
    listen
    route(/.?/) { |req, res| res &lt;&lt; "Hello World!" }
</code></pre>

<p>After you exited irb, the Plezi server started up. go to http://localhost:3000/ and see it run :)</p>

<h2>
<a id="plezi-controller-classes" class="anchor" href="#plezi-controller-classes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Plezi Controller classes</h2>

<p>One of the best things about the Plezi is it's ability to take in any class as a controller class and route to the classes methods with special support for RESTful methods (<code>index</code>, <code>show</code>, <code>new</code>, <code>save</code>, <code>update</code>, <code>delete</code>, <code>before</code> and <code>after</code>) and for WebSockets (<code>pre_connect</code>, <code>on_connect</code>, <code>on_message(data)</code>, <code>on_disconnect</code>, <code>broadcast</code>, <code>collect</code>):</p>

<pre><code>    require 'plezi'

    class Controller
        def index
            "Hello World!"
        end
    end

    listen
    route '*' , Controller
</code></pre>

<p>Except for WebSockets, returning a String will automatically add the string to the response before sending the response - which makes for cleaner code. It's also possible to send the response as it is (by returning true).</p>

<p>Controllers can even be nested (order matters) or have advanced uses that are definitly worth exploring.</p>

<p><strong>please read the demo code for Plezi::StubRESTCtrl and Plezi::StubWSCtrl to learn more.</strong></p>

<h2>
<a id="native-websocket-and-radis-support" class="anchor" href="#native-websocket-and-radis-support" aria-hidden="true"><span class="octicon octicon-link"></span></a>Native Websocket and Radis support</h2>

<p>Plezi Controllers have access to native websocket support through the <code>pre_connect</code>, <code>on_connect</code>, <code>on_message(data)</code>, <code>on_disconnect</code>, <code>broadcast</code> and <code>collect</code> methods.</p>

<p>Here is some demo code for a simple Websocket broadcasting server, where messages sent to the server will be broadcasted back to all the <strong>other</strong> active connections (the connection sending the message will not recieve the broadcast).</p>

<p>As a client side, we will use the WebSockets echo demo page - we will simply put in ws://localhost:3000/ as the server, instead of the default websocket server (ws://echo.websocket.org).</p>

<p>Remember to connect to the service from at least two browser windows - to truly experience the <code>broadcast</code>ed websocket messages.</p>

<div class="highlight highlight-ruby"><pre>    <span class="pl-k">require</span> <span class="pl-s1"><span class="pl-pds">'</span>plezi<span class="pl-pds">'</span></span>

    <span class="pl-c"># do you need automated redis support?</span>
    <span class="pl-c"># require 'redis'</span>
    <span class="pl-c"># ENV['PL_REDIS_URL'] = "http://user:password@localhost:6379"</span>

    <span class="pl-k">class</span> <span class="pl-en">BroadcastCtrl</span>
        <span class="pl-k">def</span> <span class="pl-en">index</span>
            redirect_to <span class="pl-s1"><span class="pl-pds">'</span>http://www.websocket.org/echo.html<span class="pl-pds">'</span></span>
        <span class="pl-k">end</span>
        <span class="pl-k">def</span> <span class="pl-en">on_message</span> <span class="pl-vpf">data</span>
            <span class="pl-c"># try replacing the following two lines are with:</span>
            <span class="pl-c"># self.class.broadcast :_send_message, data</span>
            broadcast <span class="pl-c1">:_send_message</span>, data
            response <span class="pl-k">&lt;&lt;</span> <span class="pl-s1"><span class="pl-pds">"</span>sent.<span class="pl-pds">"</span></span>
        <span class="pl-k">end</span>
        <span class="pl-k">def</span> <span class="pl-en">_send_message</span> <span class="pl-vpf">data</span>
            response <span class="pl-k">&lt;&lt;</span> data
        <span class="pl-k">end</span>
        <span class="pl-k">def</span> <span class="pl-en">people</span>
            <span class="pl-s1"><span class="pl-pds">'</span>I made this :)<span class="pl-pds">'</span></span>
        <span class="pl-k">end</span>
    <span class="pl-k">end</span>

    listen 

    route <span class="pl-s1"><span class="pl-pds">'</span>/<span class="pl-pds">'</span></span>, <span class="pl-vo">BroadcastCtrl</span></pre></div>

<p>method names starting with an underscore ('_') will NOT be made public by the router: so while '/people' is public ( <a href="http://localhost:3000/people">try it</a> ), '/_send_message' will return a 404 not found error ( <a href="http://localhost:3000/_send_message">try it</a> ).</p>

<h2>
<a id="native-http-streaming-with-asynchronous-events" class="anchor" href="#native-http-streaming-with-asynchronous-events" aria-hidden="true"><span class="octicon octicon-link"></span></a>Native HTTP streaming with Asynchronous events</h2>

<p>Plezi comes with native HTTP streaming support, alowing you to use Plezi Events and Timers to send an Asynchronous response.</p>

<p>Let's make the classic 'Hello World' use HTTP Streaming and Asynchronous Plezi Events:</p>

<div class="highlight highlight-ruby"><pre>        <span class="pl-k">require</span> <span class="pl-s1"><span class="pl-pds">'</span>plezi<span class="pl-pds">'</span></span>

        <span class="pl-k">class</span> <span class="pl-en">Controller</span>
            <span class="pl-k">def</span> <span class="pl-en">index</span>
                response.start_http_streaming
                <span class="pl-s3">PL</span>.callback(response, <span class="pl-c1">:send</span>, <span class="pl-s1"><span class="pl-pds">"</span>Hello World<span class="pl-pds">"</span></span>) { response.finish }
                <span class="pl-c1">true</span>
            <span class="pl-k">end</span>
        <span class="pl-k">end</span>

        listen
        route <span class="pl-s1"><span class="pl-pds">'</span>*<span class="pl-pds">'</span></span> , <span class="pl-vo">Controller</span></pre></div>

<p>Notice the easy use of Asynchronous Events using the PL#callback method. The optional block passed to this method (<code>response.finish</code>) will be executed only after the asynchronous call for the response#send method with the "Hello World" argument has completed.</p>

<p>More on asynchronous events and timers later.</p>

<h2>
<a id="plezi-routes" class="anchor" href="#plezi-routes" aria-hidden="true"><span class="octicon octicon-link"></span></a>Plezi Routes</h2>

<p>Plezi supports magic routes, in similar formats found in other systems, such as: <code>route "/:required/(:optional_with_format){[\\d]*}/(:optional)", Plezi::StubRESTCtrl</code>.</p>

<p>Plezi assummes all simple string routes to be RESTful routes woth the parameter <code>:id</code> ( <code>"/user" == "/user/(:id)"</code> ).</p>

<pre><code>require 'plezi'
listen

# this route demos a route for listing/showing posts,
# with or without revision numbers or page-control....
# notice the single quotes (otherwise the '\' would need to be escaped).
route '/post/(:id)/(:revision){[\d]+\.[\d]+}/(:page_number)', Plezi::StubRESTCtrl
</code></pre>

<p>now visit:</p>

<ul>
<li><a href="http://localhost:3000/post/12/1.3/1">http://localhost:3000/post/12/1.3/1</a></li>
<li><a href="http://localhost:3000/post/12/1">http://localhost:3000/post/12/1</a></li>
</ul>

<p><strong>please see the <code>route</code> documentation for more information on routes</strong>.</p>

<h2>
<a id="plezi-virtual-hosts" class="anchor" href="#plezi-virtual-hosts" aria-hidden="true"><span class="octicon octicon-link"></span></a>Plezi Virtual Hosts</h2>

<p>Plezi can be used to create virtual hosts for the same service:</p>

<pre><code>require 'plezi'
listen
host 'localhost', alias: 'localhost2'

shared_route '/people' do |req, res|
    res &lt;&lt; "we are people - shared by all routes."
end

host

route('*') do |req, res|
    res &lt;&lt; "this is a 'catch-all' host. you got here by putting in the IP adderess."
end

host 'localhost'

route('*') do |req, res|
    res &lt;&lt; "this is localhost or localhost 2"
end
</code></pre>

<p>Now visit:</p>

<ul>
<li><a href="http://127.0.0.1:3000/">http://127.0.0.1:3000/</a></li>
<li><a href="http://localhost:3000/">http://localhost:3000/</a></li>
<li><a href="http://127.0.0.1:3000/people">http://127.0.0.1:3000/people</a></li>
<li><a href="http://localhost:3000/people">http://localhost:3000/people</a></li>
</ul>

<h2>
<a id="plezi-logging" class="anchor" href="#plezi-logging" aria-hidden="true"><span class="octicon octicon-link"></span></a>Plezi Logging</h2>

<p>The Plezi module (also <code>PL</code>) has methods to help with logging as well as the support you already noticed for dynamic routes, dynamic services and more.</p>

<p>Logging:</p>

<pre><code>require 'plezi'

# simple logging of strings
PL.info 'log info'
PL.warn 'log warning'
PL.error 'log error'
PL.fatal "log a fatal error (shuoldn't be needed)."
PL.log_raw "Write raw strings to the logger."

# the logger accepts exceptions as well.
begin
    raise "hell"
rescue Exception =&gt; e
    PL.error e
end
</code></pre>

<h2>
<a id="plezi-events-and-timers" class="anchor" href="#plezi-events-and-timers" aria-hidden="true"><span class="octicon octicon-link"></span></a>Plezi Events and Timers</h2>

<p>The Plezi module (also <code>PL</code>) also has methods to help with asynchronous tasking, callbacks, timers and customized shutdown cleanup.</p>

<p>Asynchronous callbacks (works only while services are active and running):</p>

<pre><code>require 'plezi'

def my_shutdown_proc time_start
    puts "Services were running for #{Time.now - time_start} ms."
end

# shutdown callbacks
PL.on_shutdown(Kernel, :my_shutdown_proc, Time.now) { puts "this will run after shutdown." }
PL.on_shutdown() { puts "this will run too." }

# a timer
PL.run_after 2, -&gt; {puts "this will wait 2 seconds to run... too late. for this example"}

# an asynchronous method call with an optional callback block
PL.callback(Kernel, :puts, "Plezi will start eating our code once we exit terminal.") {puts 'first output finished'}
</code></pre>

<h2>
<a id="food-for-thought---advanced-controller-uses" class="anchor" href="#food-for-thought---advanced-controller-uses" aria-hidden="true"><span class="octicon octicon-link"></span></a>Food for thought - advanced controller uses</h2>

<p>Here's some food for thought - code similar to something actually used at some point while developing the applicatio template used by <code>plezi new myapp</code>:</p>

<pre><code>require 'plezi'

# this controller will re-write the request to extract data,
# and then it will fail, so that routing continues.
#
# this is here just for the demo.
#
class ReWriteController
    # using the before filter and regular expressions to make some changes.
    def before
        # extract the fr and en locales.
        result = request.path.match /^\/(en|fr)($|\/.*)/

        if result
            params[:locale] = result[1]
            request.path = result[2]
        end

        # let the routing continue.
        return false
    end
end

class Controller
    def index
        return "Bonjour le monde!" if params[:locale] == 'fr'
        "Hello World!\n #{params}"
    end
    def show
        return "Vous êtes à la recherche d' : #{params[:id]}" if params[:locale] == 'fr'
        "You're looking for: #{params[:id]}"
    end
    def debug
        # binding.pry
        # do you use pry for debuging?
        # no? oh well, let's ignore this.
        false
    end
    def delete
        return "Mon Dieu! Mon français est mauvais!" if params[:locale] == 'fr'
        "did you try /#{params["id"]}/?_method=delete or does your server support a native DELETE method?"
    end
end

listen

# we run the ReWriteController first, to rewrite the path for all the remaining routes.
#
# this is here just for the demo...
#
# ...in this specific case, it is possible to dispense with the ReWriteController class
# and write:
#
# route '/(:locale){fr|en}/*', false
#
# the false controller acts as a simple path re-write that
# deletes everything before the '*' sign (the catch-all).
#
route '*' , ReWriteController

# this route takes a regular expression that is a simple math calculation
# (calculator)
route /^\/[\d\+\-\*\/\(\)\.]+$/ do |request, response|
    message = (request.params[:locale] == 'fr') ? "La solution est" : "My Answer is"
    response &lt;&lt; "#{message}: #{eval(request.path[1..-1])}"
end

route "/users" , Controller

route "/" , Controller
</code></pre>

<p>try:</p>

<ul>
<li><a href="http://localhost:3000/">http://localhost:3000/</a></li>
<li><a href="http://localhost:3000/fr">http://localhost:3000/fr</a></li>
<li><a href="http://localhost:3000/users/hello">http://localhost:3000/users/hello</a></li>
<li><a href="http://localhost:3000/(5+5*20-15)/9">http://localhost:3000/(5+5*20-15)/9</a></li>
<li><a href="http://localhost:3000/fr/(5+5*20-15)/9">http://localhost:3000/fr/(5+5*20-15)/9</a></li>
<li><a href="http://localhost:3000/users/hello?_method=delete">http://localhost:3000/users/hello?_method=delete</a></li>
</ul>

<h2>
<a id="plezi-settings" class="anchor" href="#plezi-settings" aria-hidden="true"><span class="octicon octicon-link"></span></a>Plezi Settings</h2>

<p>Plezi is ment to be very flexible. please take a look at the Plezi Module for settings you might want to play with (max_threads, idle_sleep, create_logger) or any monkey patching you might enjoy.</p>

<p>Feel free to fork or contribute. right now I am one person, but together we can make something exciting that will help us enjoy Ruby in this brave new world and (hopefully) set an example that will induce progress in the popular mainstream frameworks such as Rails and Sinatra.</p>

<h2>
<a id="contributing" class="anchor" href="#contributing" aria-hidden="true"><span class="octicon octicon-link"></span></a>Contributing</h2>

<ol>
<li>Fork it ( <a href="https://github.com/boazsegev/plezi-server/fork">https://github.com/boazsegev/plezi-server/fork</a> )</li>
<li>Create your feature branch (<code>git checkout -b my-new-feature</code>)</li>
<li>Commit your changes (<code>git commit -am 'Add some feature'</code>)</li>
<li>Push to the branch (<code>git push origin my-new-feature</code>)</li>
<li>Create a new Pull Request</li>
</ol>
        </section>

        <aside id="sidebar">
          <a href="https://github.com/boazsegev/plezi/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/boazsegev/plezi/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>

          <p class="repo-owner"><a href="https://github.com/boazsegev/plezi"></a> is maintained by <a href="https://github.com/boazsegev">boazsegev</a>.</p>

          <p>This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the Architect theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.</p>
        </aside>
      </div>
    </div>

  
  </body>
</html>
